# Погружение в Python. Коллекции.
# Списки list - в каждой элементе хранится ссылка на объект, то есть может быть внутри листы любые объекты, точнее указатели.
import copy

list_1 = list()
list_2 = list((3.14, True, "Hello world"))
list_3 = [] #  немного быстрее работает
list_4 = [3.14, True, "Hello world"]

# append()
list_4.append("string") # добавляет в конце списка строку
list_4.append(list_2) # вложенный список
print(list_4)

# extend()
b = "Hello"
list_2.extend(b)  # последовательно добавит элементы строки
print(list_2)

# pop() - удаляет со сдвигом
list_2.pop(2)
print(list_2)

# count() - считает заданные элементы в массиве
print(list_2.count('l'))

# index() - ищем индекс указанного элемента
print(list_2.index('e'))

# insert(pos, object) - вставляет на указанную пощицию объект
list_2.insert(3, 'u')
print(list_2)

# remove() - удалить объект по значению (пробегает по всему списку)
list_2.remove('u')
print(list_2)

# изменение порядка элементов списка, но может сортировать любые последовательности
# sorted() O(n)*logN по времени и O(n) по памяти
my_list_1 = list((3, 1, 6, 12, 6, 2, 99, 0))
sort_list = sorted(my_list_1)
print(sort_list)

# sort() не создает новый массив, а сортирует текущий. Сортирует только списки.
# reversed() разворачивает список, но возвращает объект list_reverseiterator
my_list_1 = [4, 8, 2, 9, 1, 7, 2]
res = reversed(my_list_1)
print(type(res), res)
rev_list = list(reversed(my_list_1))
print(rev_list)
# можно использовать reversed() цикле
for item in reversed(my_list_1):
    print(item)
# reverse() - метод который может развернуть список сразу в том же массиве
# также разворот можно сделать так my_list_1[::-1]

# Срезы - позволяет получить часть списка в виде нового списка (это тоже копия)
# если указать шаг отрицательный, то сред будет выполнен в обратную сторону
print(my_list_1[1:5:2])
# Копирование. При обычном переприсвоении списков просто создаются две разные ссылки на один объект.
# Для того, чтобы сделать два списка можно использовать метод copy() - поверхнотсные копия списка
new_list = my_list_1.copy()
my_list_1.append(555)
print(new_list)
print(my_list_1)
# Глубокое копирования. При порядке вложенности больше 1 обычное копирование не сработает, скопируется только 1-ый
# уровень вложенности. deepcopy() будет рекурсивно обходить всю коллекцию и копирует её.
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_matrix = copy.deepcopy(matrix)
print(matrix, new_matrix, sep='\n')
matrix[0][1] = 555
print(matrix, new_matrix, sep='\n')

#  len(x) - возвращается количество элементов коллекции, но не учитывает вложенные коллекции.
#
#

